есть вот такие компоненты собранные на технологии webcomponents

```
import { Primitive } from 'node_modules/ohae_state/dist/types/index.js';
import { OhaeUI } from '../../OhaeUI.ts';
import { AlignValues, EventHandler, EventHandlers, IOhaeViewOptions, LayoutDirection } from '../../OhaeViewOptions.ts';
import { StateConnector } from '../../state/StateConnector.ts';
import { Color } from '../../utils/Color.ts';

// import styles from './OhaeBaseView.css?raw';
// import fontawesome from './fontawesome.css?raw';
// import html from './OhaeBaseView.html?raw';

// console.log('>>>', 'OhaeBaseView', styles);
import { SizeNumber } from '../../utils/SizeNumber.ts';


export class OhaeBaseView extends HTMLElement {
	public static readonly ATTRIBUTES: string[] = [
		'id',
		'align',
		'valign',
		'flex',
		'width',
		'height',
		'maxWidth',
		'maxHeight',
		'minWidth',
		'minHeight',
		'padding',
		'margin',
		'backgroundColor',
		'parentdirection',
	];

	protected static readonly STYLES: string = `<style>
		:host {
			border-radius: 3px;
			display: flex;
			box-sizing: border-box;
			padding: 0px;
			margin: 0px;
			flex: none;
		}
		:host([backgroundColor]) {
			box-shadow: 2px 2px 2px rgba(0, 0, 0, .1);
			background-color:  var(--host-bg, #333);
			color: var(--host-color, #aaa);
		}

		</style>`;

	protected static readonly FONT_AVESOME: string = `<style>
		@import url("./assets/fontawesome-free-6.7.2-web/css/all.min.css");
	</style>`;

	protected static readonly HTML: string = `<slot></slot>`;

	protected static readonly JUSTIFY_VALUES_MAP: Record<AlignValues, string> = {
		'flex-start': 'left', 			// Элементы выравниваются по началу основной оси (по умолчанию).
		'flex-end': 'right', 			// Элементы выравниваются по концу основной оси.
		'center': 'center', 			// Элементы выравниваются по центру основной оси.
		'space-between': 'justify', 	// Элементы распределяются равномерно по основной оси, первый элемент прижимается к началу, последний — к концу, а остальные равномерно распределяются.
		'space-around': 'justify', 		// Элементы распределяются равномерно, но с равными промежутками вокруг каждого элемента.
		'space-evenly': 'justify', 		// Элементы распределяются равномерно, включая промежутки до первого и после последнего элемента.
		'start': 'left', 				// Элементы выравниваются по началу контейнера (по оси написания текста, обычно для текстов слева направо).
		'end': 'right', 				// Элементы выравниваются по концу контейнера (по оси написания текста, обычно для текстов справа налево).
		'none': 'left'
	}
	public readonly onReady: Promise<boolean>;
	private _readyResolve!: (value: boolean | PromiseLike<boolean>) => void;
	protected onInitDataReady!: Promise<boolean>;
	protected initData!: IOhaeViewOptions;
	private _initDataReadyResolve!: (value: boolean | PromiseLike<boolean>) => void;
	protected shadow!: ShadowRoot;


	constructor() {
		super();
		this.onReady = new Promise((resolve) => this._readyResolve = resolve);
		this.onInitDataReady = new Promise((resolve) => this._initDataReadyResolve = resolve);
		this.shadow = this.attachShadow({ mode: 'open' });
		this.createCallback();
	}

	static get observedAttributes(): string[] {
		return [...OhaeBaseView.ATTRIBUTES];
	}

	protected async connectedCallback() {
		// await this.createCallback();
		this.markAsReady();
	}

	protected async createCallback() {
		await this.onInitDataReady;
		await this.render();
		this.applyAttributes(OhaeBaseView.observedAttributes);
	}

	protected markAsReady() {
		this._readyResolve(true);
	}

	protected markAsInitDataReady() {
		this._initDataReadyResolve(true);
	}

	public init(options: IOhaeViewOptions) {
		this.initData = options;
		this.initState();
		this.initAttributes();
		this._initDataReadyResolve(true);
	}

	protected initState(){
		const stateData = this.initData?.stated;
		const state = StateConnector.getState(this)
		if(state && stateData){
			console.log(0, state, stateData)
			Object.entries(stateData).forEach(([attribute, statePath]) => {
				console.log(1, attribute, statePath)

				const value = state.getValue(statePath as string) as Primitive;
				console.log(2, value)
				if(value!==null && value!==undefined){
					this.initData[attribute] = value;
					// this.applyAttribute(attribute, value.toString());
				}

			});
		}
	}
	protected initAttributes(){
		Object.entries(this.initData ?? {}).forEach(([key, value]) => {
			if (key === 'id') {
				this.setAttribute(key, OhaeUI.getPrefixedId(value));
			} else if (typeof value != 'object' && value !== undefined) {
				if (value !== null) this.setAttribute(key, value.toString());
			}
		});
	}

	protected disconnectedCallback() {
	}

	protected attributeChangedCallback(name: string, oldValue: string, newValue: string) {
		if (oldValue !== newValue) {
			this.applyAttribute(name, newValue);
		}
	}

	protected async render() {
		const staticThis = (this.constructor as typeof OhaeBaseView);
		this.shadowRoot!.innerHTML = staticThis.STYLES + staticThis.HTML;
	}

	public override addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {
		super.addEventListener(type, listener, options);
	}

	protected applyAttributes(attributes: string[]): void {
		attributes.forEach(name => {
			const value = this.getAttribute(name);
			if (value !== null) this.applyAttribute(name, value);
		});
	}

	protected applyAttribute(name: string, value: string): void {
		// if(name === 'flex') console.log('>>>', 'update attribute', 3, 'flex', value);
		if (!(name in this)) return;
		(this as any)[name] = value;
		const typedValue = (this as any)[name];
		// if(name === 'flex') console.log('>>>', 'update attribute', 4, 'flex', typedValue);

		const stateData = this.initData?.stated?.[name];
		// if(name === 'flex') console.log('>>>', 'update attribute', 5, 'stated', this.initData?.stated);
		if(!stateData) return;
		// if(name === 'flex') console.log('>>>', 'update attribute', 6, 'flex', typedValue);

		const state = StateConnector.getState(this)
		// if(name === 'flex') console.log('>>>', 'update attribute', 7, 'stated', stateData, typedValue, this.initData?.stated, state);

		state?.setValue(stateData as string, typedValue);
	}

	protected waitForShadowRoot(hostElement: HTMLElement = this): Promise<ShadowRoot> {
		return new Promise((resolve) => {
			if (hostElement.shadowRoot) {
				return resolve(hostElement.shadowRoot);
			}

			const observer = new MutationObserver((_, obs) => {
				if (hostElement.shadowRoot) {
					obs.disconnect();
					resolve(hostElement.shadowRoot);
				}
			});

			observer.observe(hostElement, {
				childList: false,
				subtree: false,
				attributes: false,
				// Наблюдаем за изменениями, связанными с ShadowRoot
				characterData: false,
			});
		});
	};

	get flex(): number | null {
		const value = this.getAttribute('flex');
		if (!value) return null
		return parseFloat(value);
	}
	set flex(value: string | number | null) {
		// console.log('>>>', 'update property', 0, 'flex', value);
		if (value === null) return;
		// console.log('>>>', 'update property', 1, 'flex', value);
		if (value === 'none') {
			this.style.flexGrow = 'none';
			this.setAttribute('flex', 'none');
		} else if (typeof value === 'number') {
			this.style.flexGrow = value.toString();
			this.setAttribute('flex', value.toString());
		} else {
			this.style.flexGrow = value;
		}
	}

	get backgroundColor(): Color | null {
		const backgroundColor = this.getAttribute('backgroundColor');
		if (!backgroundColor) return null;
		return new Color(backgroundColor);
	}
	set backgroundColor(value: string | Color | null) {
		if (!value) return;

		const color = typeof value === 'string' ? new Color(value) : value;
		this.setAttribute('backgroundColor', color.hex);

		this.style.setProperty("--host-bg", color.hex);
		this.style.setProperty("--host-color", color.contrast(0.5).mono().hex);
		this.style.setProperty("--host-hr-color", color.contrast(0.2).mono().hex);

		this.style.setProperty("--host-hover-bg", color.brightness(1.1).hex);
		this.style.setProperty("--host-active-bg", color.brightness(1.2).hex);
		this.style.setProperty("--host-border", color.brightness(0.8).hex);
		this.style.setProperty("--host-head-bg", color.brightness(0.5).mono().hex);
		this.style.setProperty("--host-head-color", color.contrast(0.5).mono().hex);
	}

	get align(): string | null {
		return this.getAttribute('valign');
	}
	set align(value: string | null) {
		if (value === null) return;
		this.setAttribute('align', value);
		this.style.textAlign = OhaeBaseView.JUSTIFY_VALUES_MAP[value as AlignValues];
		this.style.justifyContent = value;
	}

	get valign(): string | null {
		return this.getAttribute('align');
	}
	set valign(value: string | null) {
		if (value === null) return;
		this.style.alignItems = value;
	}

	get margin(): string | null {
		return this.getAttribute('margin');
	}
	set margin(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('margin', parsedValue);
		this.style.margin = parsedValue;
	}

	get padding(): string | null {
		return this.getAttribute('padding');
	}
	set padding(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('padding', parsedValue);
		this.style.padding = parsedValue;
	}

	get height(): string | null {
		return this.getAttribute('height');
	}
	set height(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('height', parsedValue);
		this.style.height = parsedValue;
	}

	get minHeight(): string | null {
		return this.getAttribute('minHeight');
	}

	set minHeight(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('minHeight', parsedValue);
		this.style.minHeight = parsedValue;
	}

	get maxHeight(): string | null {
		return this.getAttribute('maxHeight');
	}
	set maxHeight(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('maxHeight', parsedValue);
		this.style.maxHeight = parsedValue;
	}

	get width(): string | null {
		return this.getAttribute('width');
	}
	set width(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('width', parsedValue);
		this.style.width = parsedValue;
	}

	get minWidth(): string | null {
		return this.getAttribute('minWidth');
	}
	set minWidth(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('minWidth', parsedValue);
		this.style.minWidth = parsedValue;
	}

	get maxWidth(): string | null {
		return this.getAttribute('maxWidth');
	}

	set maxWidth(value: string | number | null) {
		if (value === null) return;
		const parsedValue = this.parseSizeValue(value);
		this.setAttribute('maxWidth', parsedValue);
		this.style.maxWidth = parsedValue;
	}

	protected parseSizeValue(value: string | number): string {
		value = value.toString()
		const parsedNumber = parseFloat(value);
		if (typeof parsedNumber === 'number') {
			const number = new SizeNumber(value);
			return number.toString();
		} else {
			return value;
		}
	}

	protected parseNumberValue(value: string | number): string {
		const number = new SizeNumber(value);
		return number.toNumber().toString();
	}

	protected setBooleanAttribute(attributeName: string, value: boolean | string | null, target?: HTMLElement): boolean {
		value = value === true || value === 'true';
		target = target ?? this;
		if (value) {
			target.setAttribute(attributeName, value.toString());
		} else {
			target.removeAttribute(attributeName);
		}
		return value;
	}
}

OhaeUI.registerViewType('base', OhaeBaseView);
```

```
import { OhaeUI } from '../../OhaeUI';
import { OhaeBaseView } from '../base_view/OhaeBaseView';

export class OhaeLayoutView extends OhaeBaseView {
    public static readonly ATTRIBUTES: string[] = [
        'collapsed',
        'direction',
        'overflow',
        'overflowX',
        'overflowY',
    ];
	protected static readonly STYLES: string = `
        <style>
            :host {
                border-radius: 3px;
                display: flex;
                overflow: auto;
                box-sizing: border-box;
                padding: 0px;
                margin: 0px;
                flex-grow: 1;
            }
            /* :host(:not([backgroundColor])) { */
            :host([backgroundColor]) {
                background-color:  var(--host-bg, #333);
                box-shadow: 2px 2px 2px rgba(0, 0, 0, .1);
                color: var(--host-color, #ddd);
            }
            :host([direction="rows"]) {
                flex-direction: column;
            }
            :host([direction="cols"]) {
                flex-direction: row;
            }
            :host([collapsed]) {
                display: none;
            }
            ::slotted(*) {
                flex: 1;  /* Все элементы слота будут равномерно растянуты */
                min-width: 0; /* Позволяет элементам сужаться */
            }
        </style>
	`;

    private resizeObserver: ResizeObserver;

    constructor() {
        super();
        this.resizeObserver = new ResizeObserver(() => this.handleResize());
    }

    static get observedAttributes() {
        return [...super.observedAttributes, ...this.ATTRIBUTES];
    }

    protected override async createCallback() {
        await super.createCallback();
        this.applyAttributes(OhaeLayoutView.ATTRIBUTES);
        this.resizeObserver.observe(this);
    }

    protected override disconnectedCallback() {
        super.disconnectedCallback();
        this.resizeObserver.disconnect();
    }

    private handleResize() {
        // Логика для обработки изменения размеров
    }

    public show() {
        this.collapsed = false;
    }

    public hide() {
        this.collapsed = true;
    }

    get overflow(): string | null {
        return this.getAttribute('overflow');
    }
    set overflow(value: string | null) {
        if (value === null) return;
        this.setAttribute('overflow', value);
        this.style.overflow = value;
    }

    get overflowX(): string | null {
        return this.getAttribute('overflowX');
    }
    set overflowX(value: string | null) {
        if (value === null) return;
        this.setAttribute('overflowX', value);
        this.style.overflowX = value;
    }

    get overflowY(): string | null {
        return this.getAttribute('overflowY');
    }
    set overflowY(value: string | null) {
        if (value === null) return;
        this.setAttribute('overflowY', value);
        this.style.overflowY = value;
    }

    get collapsed(): boolean {
		return this.getAttribute('collapsed') === 'true';
	};
	set collapsed(value: boolean | string | null) {
        this.setBooleanAttribute('collapsed', value);
    }
}

OhaeUI.registerViewType('layout', OhaeLayoutView);


declare module "../../OhaeViewOptions" {
    interface IOhaeViewOptions {
        collapsed?: boolean | string;
        direction?: LayoutDirection;
        overflow?: string;
        overflowX?: string;
        overflowY?: string;
    }
}
```

```
import { OhaeUI } from "../../OhaeUI";
import { OhaeBaseView } from "../base_view/OhaeBaseView";

interface IElement {
    element: HTMLElement;
    initialSize: number;
    minSize: number;
    maxSize: number;
    newSize: number;
}

export class OhaeResizerView extends OhaeBaseView {
    public static readonly ATTRIBUTES: string[] = [

    ];
    protected static readonly STYLES: string = `
        <style>
            :host {
                display: block;
                padding: 0px;
                margin: 1px;
            }
            :host([direction="cols"]) {
                /* background: url("data:image/gif;base64,R0lGODlhAwAdAIABAJWr7f///yH5BAEAAAEALAAAAAADAB0AAAIQRBynaaje0pORrWnhrbi3AgA7") no-repeat center center; */
                cursor: e-resize;
            }
            :host([direction="rows"]) {
                /* background:  url("data:image/gif;base64,R0lGODlhHQADAIABAJWr7f///yH5BAEAAAEALAAAAAAdAAMAAAINRIynyesBo5y0tuswKgA7") no-repeat center center; */
                cursor: n-resize;
            }

            :host([direction="cols"]:hover) .overlay2{
                transform: scaleX(7);
            }
            :host([direction="rows"]:hover) .overlay2{
                transform: scaleY(7);
            }

            :host([direction="cols"]:active) .overlay2{
                transform: scaleX(4);
            }
            :host([direction="rows"]:active) .overlay2{
                transform: scaleY(4);
            }

            :host([direction="cols"]) .overlay2{
                transform: scaleX(4);
            }
            :host([direction="rows"]) .overlay2{
                transform: scaleY(4);
            }

            .container {
                position: relative;
                width: inherit;
                height: 100%;
                border: none;
                padding: 0px;
                margin: 0px;
            }
            .overlay1, .overlay2 {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }

            .overlay1 {
                background-color: #222;
            }

            :host([direction="cols"]) .overlay1{
                background: url("data:image/gif;base64,R0lGODlhAwAdAIABAJWr7f///yH5BAEAAAEALAAAAAADAB0AAAIQRBynaaje0pORrWnhrbi3AgA7") no-repeat center center;
            }
            :host([direction="rows"]) .overlay1{
                background:  url("data:image/gif;base64,R0lGODlhHQADAIABAJWr7f///yH5BAEAAAEALAAAAAAdAAMAAAINRIynyesBo5y0tuswKgA7") no-repeat center center;
            }


            :host(:hover) .overlay1{
                background-color: #191919; /* #415e9c60;*/
            }

            :host(:active) .overlay1{
                /* Эффект при нажатии */
                background-color: #555;
            }

            .overlay2 {
                background: transparent;
            }
            .overlay2_ {
                background:  rgba(255, 0, 0, 0.5);
            }
        </style>
	`;
	protected static readonly HTML: string = `
		<slot><div class="container">
            <div class="overlay1"></div>
            <div class="overlay2"></div>
        </div></slot>
	`;
    private startX: number = 0;
    private startY: number = 0;
    private beforeElements: IElement[] = [];
    private afterElements: IElement[] = [];
    private currentDragDelta: number = 0;

    static get observedAttributes() {
        return [...super.ATTRIBUTES, ...this.ATTRIBUTES];
    }

    protected override async createCallback() {
        await super.createCallback()
        this.setAttribute('direction', this.isRows() ? 'rows' : 'cols');
        this.applyDirrection();
        this.addEventListener('mousedown', this.handleMouseDown as EventListener);
    }

    protected override disconnectedCallback() {
        this.removeEventListener('mousedown', this.handleMouseDown);
    }

    protected applyDirrection() {
        // if (!this.isConnected) return;
        if (this.isRows()) {
            this.style.height = '2px';
            this.style.minHeight = '2px';
            this.style.maxHeight = '2px';
        } else {
            this.style.width = '2px';
            this.style.minWidth = '2px';
            this.style.maxWidth = '2px';
        }
    }

    private isRows(): boolean {
        const container = this.parentElement as HTMLElement;
        return container.getAttribute('direction') === 'rows';
    }

    private storeElements(): void {
        const container = this.parentElement as HTMLElement;
        if (!container) return;

        const elements = Array.from(container.children) as HTMLElement[];

        this.beforeElements = [];
        this.afterElements = [];

        let isBefore = true;
        elements.forEach(element => {
            if (element === this) {
                isBefore = false;
                return;
            }

            const size = this.isRows() ? element.offsetHeight : element.offsetWidth;
            const minSize = parseFloat(getComputedStyle(element)[this.isRows() ? 'minHeight' : 'minWidth']) || 0;
            const maxSize = parseFloat(getComputedStyle(element)[this.isRows() ? 'maxHeight' : 'maxWidth']) || Infinity;
            const data = { element, initialSize: size, minSize, maxSize, newSize: size } as IElement;

            if (isBefore) {
                this.beforeElements.unshift(data);
            } else {
                this.afterElements.push(data);
            }
        });
    }

    private decreaseSizeRecursive(items: IElement[], deltaToDistribute: number) {
        const item = items.shift();
        if (!item) {
            this.currentDragDelta -= deltaToDistribute;
            return;
        }
        const actualDecrease = Math.min(deltaToDistribute, item.initialSize - item.minSize);
        item.newSize = item.initialSize - actualDecrease;
        if (actualDecrease <= deltaToDistribute) {
            this.decreaseSizeRecursive(items, deltaToDistribute - actualDecrease);
        } else {
            this.currentDragDelta -= deltaToDistribute;
        }
    }

    private increaseSizeRecursive(items: IElement[], deltaToDistribute: number) {
        const item = items.shift();
        if (!item) {
            this.currentDragDelta -= deltaToDistribute;
            return;
        }
        const actualIncrease = Math.min(deltaToDistribute, item.maxSize - item.initialSize);
        item.newSize = item.initialSize + actualIncrease;
        if (actualIncrease <= deltaToDistribute) {
            this.increaseSizeRecursive(items, deltaToDistribute - actualIncrease);
        } else {
            this.currentDragDelta -= deltaToDistribute;
        }
    }

    private applyNewSizes() {
        const allAffectedElements = [...this.beforeElements, ...this.afterElements];
        allAffectedElements.forEach((item, i) => {
            if(item.element instanceof OhaeBaseView){
                item.element.flex = item.newSize;
            }else{
                item.element.style.flexGrow = `${item.newSize}`;
            }

        });
    }


    private handleMouseDown = (event: MouseEvent) => {
        event.preventDefault();
        this.startX = event.clientX;
        this.startY = event.clientY;

        this.storeElements()

        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
    };

    private handleMouseMove = (event: MouseEvent) => {
        const container = this.parentElement as HTMLElement;
        if (!container) return;

        let delta = this.isRows() ? event.clientY - this.startY : event.clientX - this.startX;
        this.currentDragDelta = Math.abs(delta);

        if (delta < 0) {
            this.decreaseSizeRecursive([...this.beforeElements], this.currentDragDelta);
            this.increaseSizeRecursive([...this.afterElements], this.currentDragDelta);
            this.decreaseSizeRecursive([...this.beforeElements], this.currentDragDelta);
        } else {
            this.decreaseSizeRecursive([...this.afterElements], this.currentDragDelta);
            this.increaseSizeRecursive([...this.beforeElements], this.currentDragDelta);
            this.decreaseSizeRecursive([...this.afterElements], this.currentDragDelta);
        }

        this.applyNewSizes();
    };

    private handleMouseUp = () => {
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
    };
}

OhaeUI.registerViewType('resizer', OhaeResizerView);
```

```
import { OhaeUI } from '../../OhaeUI';
import { SizeNumber } from '../../utils/SizeNumber';
import { OhaeLayoutView } from './OhaeLayoutView';

export class OhaeSeparatorView extends OhaeLayoutView {
	public static readonly ATTRIBUTES: string[] = [
		// 'direction',
		'size',
		'padding',
		'margin',
		'backgroundColor'
	];

	protected static readonly STYLES: string = `
        <style>
            :host {
                display: block;
                margin: 1px;
				padding: 0px;
                background-color: #222;
			}
        </style>
	`;

	static get observedAttributes() {
		return [...this.ATTRIBUTES];
	}

	protected override async createCallback() {
		await super.createCallback();
		this.setAttribute('direction', this.isRows() ? 'rows' : 'cols');
		this.applyAttributes(OhaeLayoutView.ATTRIBUTES);
		this.applyDirrection();
	}

	protected applyDirrection() {
		if (!this.isConnected) return;
		// console.log(this.isRows());
		if (this.isRows()) {
			// this.style.width = '100%';
			this.style.height = this.size;
			this.style.minHeight = this.size;
			this.style.maxHeight = this.size;
		} else {
			this.style.width = this.size;
			this.style.minWidth = this.size;
			this.style.maxWidth = this.size;
			// this.style.height = '100%';
		}
	}

	private isRows(): boolean {
		const container = this.parentElement as HTMLElement;
		return container.getAttribute('direction') === 'rows';
	}

	get size(): string {
		return this.getAttribute('size') ?? '1px';
	}
	set size(value: string | number | null) {
		if (value === null) return;
		const number = new SizeNumber(value);
		const parsedValue = number.toString();
		this.setAttribute('size', parsedValue);
		this.applyDirrection();
	}
}

OhaeUI.registerViewType('separator', OhaeSeparatorView);
```


и вот эти же компоненты переделанные под svelte версии 5.28
```
<svelte:options customElement={{ tag: "ohae-layout" }} />

<script lang="ts">
  import { useShadowTheme } from "../../lib/useShadowTheme";
  import { calculateLayoutStyles, type TFlexDirection, type ILayoutStyleProps, type ILayoutProps, asignLayoutProps } from "../../lib/layoutUtils";

  let {
    flex = undefined,
    align = "left",
    valign = "stretch",
    collapsed = false,
    direction = "row" as TFlexDirection,
    overflow = "auto",
    overflowX = undefined,
    overflowY = undefined,
    width = undefined,
    height = undefined,
    maxWidth = undefined,
    maxHeight = undefined,
    minWidth = undefined,
    minHeight = undefined,
    padding = undefined,
    margin = undefined,
    className = undefined,
    customStyle = "", // Дополнительные пользовательские стили строкой
  }: ILayoutProps = $props();

  let container: HTMLDivElement;

  const calculatedStyles = $derived(calculateLayoutStyles({
    align,
    valign,
    collapsed,
    direction,
    padding,
    margin,
  }));

  asignLayoutProps(() => container?.getRootNode() as ShadowRoot | null, {
    flex,
    overflow,
    overflowX,
    overflowY,
    width,
    height,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    collapsed,
  });

  useShadowTheme(() => container?.getRootNode() as ShadowRoot | null);
</script>

<div
  bind:this={container}
  class="slot {className}"
  style:flex-direction={calculatedStyles.finalFlexDirection}
  style:align-items={calculatedStyles.finalAlignItems}
  style:justify-content={calculatedStyles.finalJustifyContent}
  style:padding={calculatedStyles.paddingStyle}
  style:margin={calculatedStyles.marginStyle}
  style="{customStyle}"
>
  <slot></slot>
</div>

<style>
  :host, .slot {
    box-sizing: border-box;
    border: none;
    padding: 0;
    margin: 0;
  }

  :host {
    flex: 1 1 0;
    overflow: auto;
    border-radius: 3px;
    width: 100%;
  }

  .slot {
    display: flex;
    flex-direction: column;
    align-content: stretch;
    align-items: stretch;

    overflow: visible;
    width: 100%;
    height: 100%;
  }
</style>
```

```
import { onMount } from 'svelte';
import { writable, type Writable } from 'svelte/store';

// Глобальная реактивная переменная
export const themeStore: Writable<string> = writable('/themes/theme-default-light.css'); // Пример значения

export function useShadowTheme(getShadowRoot: () => ShadowRoot | null): void {
  let themeLinkElement: HTMLLinkElement | null = null;

  onMount(() => {
    const shadowRoot = getShadowRoot();

    if (!shadowRoot) {
      console.warn('[useShadowTheme] ShadowRoot is not available on mount.');
      return;
    }

    let existingLink = shadowRoot.querySelector('link[rel="stylesheet"][data-managed-theme="true"]');

    if (existingLink) {
      themeLinkElement = existingLink as HTMLLinkElement;
    } else {
      themeLinkElement = document.createElement('link');
      themeLinkElement.rel = 'stylesheet';
      themeLinkElement.setAttribute('data-managed-theme', 'true');

      let unsubscribeFromInitial: (() => void) | null = null; // Объявляем заранее
      unsubscribeFromInitial = themeStore.subscribe(initialThemePath => {
        if (themeLinkElement) {
            themeLinkElement.href = initialThemePath;
        }
        if (unsubscribeFromInitial) { // Проверяем, что функция была присвоена
          unsubscribeFromInitial(); // Теперь это безопасно
          unsubscribeFromInitial = null; // Очищаем, чтобы не вызвать дважды случайно
        }
      });

      shadowRoot.appendChild(themeLinkElement);
      shadowRoot.host.classList.add('host');
    }

    // Основная подписка на последующие изменения
    const unsubscribeFromUpdates = themeStore.subscribe(newThemePath => {
      if (themeLinkElement && themeLinkElement.href !== newThemePath) {
        themeLinkElement.href = newThemePath;
      }
    });

    return () => {
      unsubscribeFromUpdates();
    };
  });
}
```

```
import { onMount } from "svelte";

export type TFlexDirection = keyof typeof flexDirectionContentMap;
export type TOverflow = keyof typeof overflowContentMap;
export type TJustifyContent = keyof typeof justifyContentMap;
export type TAlignItems = keyof typeof alignItemsMap;


export interface ILayoutProps extends ILayoutStyleProps, ILayoutSizeProps{
    className?: string;
    customStyle?: string;
    [key: string]: any;
}

export interface ILayoutSizeProps{
    flex?: number;
    overflow?: TOverflow;
    overflowX?: TOverflow;
    overflowY?: TOverflow;
    width?: number | string;
    height?: number | string;
    maxWidth?: number;
    maxHeight?: number;
    minWidth?: number;
    minHeight?: number;
    collapsed?: boolean;
}

export interface ILayoutStyleProps {
    align?: TJustifyContent;
    valign?: TAlignItems;
    collapsed?: boolean;
    direction?: TFlexDirection;
    padding?: number | string; // Может быть числом (px) или строкой (e.g., "1em")
    margin?: number | string;
}

// Определим типы для возвращаемых вычисленных значений
export interface ICalculatedLayoutStyles {
    finalDisplay: string;
    finalFlexDirection: TFlexDirection
    finalJustifyContent: string;
    isRowDirection: boolean;
    finalAlignItems: string;
    paddingStyle?: string;
    marginStyle?: string;
}

const flexDirectionContentMap = {
    row: "row", column: "column", "row-reverse": "row-reverse", "column-reverse": "column-reverse",
    inherit: "inherit", initial: "initial", unset: "unset",
}

const overflowContentMap = {
    auto: "auto", hidden: "hidden", scroll: "scroll", visible: "visible",
    inherit: "inherit", initial: "initial", unset: "unset",
}

const justifyContentMap = {
    left: "flex-start", center: "center", right: "flex-end", start: "flex-start",
    end: "flex-end", "flex-start": "flex-start", "flex-end": "flex-end",
    "space-between": "space-between", "space-around": "space-around",
    "space-evenly": "space-evenly",
};

const alignItemsMap = {
    top: "flex-start", middle: "center", bottom: "flex-end", start: "flex-start",
    center: "center", end: "flex-end", stretch: "stretch", baseline: "baseline",
    "flex-start": "flex-start", "flex-end": "flex-end",
};

function formatSpacingValue(value: number | string | undefined): string | undefined {
    if (value === undefined) return undefined;
    if (typeof value === 'number') return `${value}px`;
    return String(value); // Позволяет передавать строки типа "1em", "5px 10px", и т.д.
}

function getDisplayValue(collapsed: boolean | undefined): string {
    return collapsed ? "none" : "flex";
}

export function calculateLayoutStyles(props: ILayoutStyleProps): ICalculatedLayoutStyles {
    const finalDisplay = getDisplayValue(props.collapsed);
    const finalFlexDirection = props.direction ?? "column";
    const isRowDirection = finalFlexDirection === "row" || finalFlexDirection === "row-reverse";

    const finalJustifyContent = justifyContentMap[props.align as keyof typeof justifyContentMap] || props.align || "flex-start";
    const finalAlignItems = alignItemsMap[props.valign as keyof typeof alignItemsMap] || props.valign || "stretch";

    const paddingStyle = formatSpacingValue(props.padding);
    const marginStyle = formatSpacingValue(props.margin);

    return {
        finalDisplay,
        finalFlexDirection,
        isRowDirection,
        finalJustifyContent,
        finalAlignItems,
        paddingStyle,
        marginStyle,
    };
}


/**
 * Определяет направление работы ресайзера ('row' или 'column').
 * Порядок приоритета:
 * 1. Явно переданный проп `explicitResizerDirection`.
 * 2. CSS-переменная `--resizer-parent-flex-direction` на родительском элементе.
 * 3. Вычисленный `flex-direction` родительского элемента.
 * @param host - Сам кастомный элемент <ohae-resizer>.
 * @param explicitPropDirection - Значение пропа explicitResizerDirection.
 * @returns Определенное направление ресайзера или null, если не удалось определить.
 */
export function determineResizerDirection(host: HTMLElement | undefined): TFlexDirection | null {
    if (!host) return null;

    //CSS переменная или вычисленный стиль родителя
    if (host.parentElement) {
        const parentElement = host.parentElement;
        let parentFlexDirection: TFlexDirection | "" = "";

        // Пытаемся прочитать CSS переменную
        const flexDirAttribute = parentElement.getAttribute('direction') as TFlexDirection | "";

        if (["row", "row-reverse", "column", "column-reverse"].includes(flexDirAttribute)) {
            parentFlexDirection = flexDirAttribute;
        } else {
            parentFlexDirection = getComputedStyle(parentElement).flexDirection as TFlexDirection;
        }

        if (parentFlexDirection === "column" || parentFlexDirection === "column-reverse") {
            return "row"; // Родитель - колонка, ресайзер - горизонтальный
        } else {
            return "column"; // Родитель - строка, ресайзер - вертикальный
        }
    }
    console.warn(">>>", 6, null);
    return null; // Не удалось определить
}

export function asignLayoutProps(getShadowRoot: () => ShadowRoot | null, sizeProps: ILayoutSizeProps): void {
    onMount(() => {
    const shadowRoot = getShadowRoot() as ShadowRoot;
    if (!shadowRoot) return;

    const hostElement = shadowRoot.host as HTMLElement;
    const style = hostElement.style;

    // if(sizeProps.width) style.width = sizeProps.width.toString();
    // if(sizeProps.height) style.height = sizeProps.height.toString();
    if(sizeProps.maxWidth) style.maxWidth = sizeProps.maxWidth.toString()+'px';
    if(sizeProps.maxHeight) style.maxHeight = sizeProps.maxHeight.toString()+'px';
    if(sizeProps.minWidth) style.minWidth = sizeProps.minWidth.toString()+'px';
    if(sizeProps.minHeight) style.minHeight = sizeProps.minHeight.toString()+'px';


    if(sizeProps.flex) style.flexGrow = sizeProps.flex.toString();
    style.display = getDisplayValue(sizeProps.collapsed);

    if(sizeProps.overflow) style.overflow = sizeProps.overflow;
    if(sizeProps.overflowX) style.overflowX = sizeProps.overflowX;
    if(sizeProps.overflowY) style.overflowY = sizeProps.overflowY;
  });
}
```

```
<svelte:options customElement={{ tag: "ohae-resizer" }} />

<script lang="ts">
  import { onMount } from "svelte";
  import {
    determineResizerDirection,
    type TFlexDirection,
  } from "../../lib/layoutUtils";
  import { useShadowTheme } from "../../lib/useShadowTheme";

  let {
    direction = "column" as TFlexDirection,
    className = undefined,
    resizeDeny = true,
  }: {
    direction: TFlexDirection;
    className?: string;
    resizeDeny: boolean;
  } = $props();

  interface IElement {
    element: HTMLElement;
    initialSize: number;
    minSize: number;
    maxSize: number;
    newSize: number;
  }

  let internalDivRef: HTMLDivElement; // внутренний <div class="resizer">
  let customElementRef: HTMLElement; // кастомный элемент <ohae-resizer>

  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let beforeElements: IElement[] = [];
  let afterElements: IElement[] = [];
  let currentDragDelta = 0; // Это Math.abs(mouseDelta)
  let isRowDirection = $derived(direction === "row");

  useShadowTheme(() => internalDivRef?.getRootNode() as ShadowRoot | null);

  onMount(() => {
    if (internalDivRef) {
      const rootNode = internalDivRef.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        customElementRef = rootNode.host as HTMLElement;
      } else {
        customElementRef = internalDivRef;
      }
    }
    direction = determineResizerDirection(customElementRef) ?? direction;

    customElementRef.addEventListener("touchstart", handleTouchDown, { passive: false });
    return () => {
      customElementRef.removeEventListener("touchstart", handleTouchDown);
    };
  });

  function getElementSize(element: HTMLElement): number {
    return isRowDirection ? element.offsetHeight : element.offsetWidth;
    // const isFlexSize = element.getAttribute("flex-size");
    // if(isFlexSize){
    //   const size = parseFloat(element.style.flexGrow);
    //   return size;
    // } else {
    //   element.setAttribute("flex-size", "true");
    //   const size = isRowDirection ? element.offsetHeight : element.offsetWidth;
    //   return size;
    // }
  }

  function getElementMinSize(element: HTMLElement): number {
    const style = getComputedStyle(element);
    const layoutLike = element as any;
    return parseFloat(isRowDirection ? layoutLike.minHeight ?? element.getAttribute("min-height") ?? style.minHeight  : layoutLike.minWidth ?? element.getAttribute("min-width") ?? style.minWidth) || 0;
  }

  function getElementMaxSize(element: HTMLElement): number {
    const style = getComputedStyle(element);
    const layoutLike = element as any;
    return parseFloat(isRowDirection ? layoutLike.maxHeight ?? element.getAttribute("max-height") ?? style.maxHeight : layoutLike.maxWidth ?? element.getAttribute("max-width") ?? style.maxWidth) || Infinity;
  }

  function getResizedElemens(): HTMLElement[] {
    if (!customElementRef?.parentElement) return [];

    const parentElement = customElementRef.parentElement;
    const parentSlot =
      parentElement.shadowRoot?.querySelector(".slot") ??
      parentElement.querySelector(".slot") ??
      parentElement;
    const children = Array.from(parentSlot.children) as HTMLElement[];
    return children.filter(item=>!!item);
  }

  function logElementsSizes(): void {
    return;
    console.log("===========================");
    const children = getResizedElemens();
    children.forEach((element) => {
      const flexSize = getElementSize(element);
      const size = isRowDirection ? element.offsetHeight : element.offsetWidth;
      console.log(element.tagName, "size", size, flexSize);
    });
    console.log("---------------------------");
  }

  function storeElements(): void {
    if (!customElementRef?.parentElement) return;

    const children = getResizedElemens();
    beforeElements = [];
    afterElements = [];
    let isBefore = true;

    children.forEach((element) => {
      const isSelf = element === customElementRef;
      if (isSelf) {
        isBefore = false;
        return;
      }

      const isHTMLElement = element instanceof HTMLElement;
      const isVisible = getComputedStyle(element).display !== "none";
      const isResizeDeny = 'resizeDeny' in element;
      const isNeedIgnore = !isHTMLElement || !isVisible || isResizeDeny;
      if (isNeedIgnore) return;

      const size = getElementSize(element);
      const minSize = getElementMinSize(element);
      const maxSize = getElementMaxSize(element);

      const data: IElement = {
        element,
        initialSize: size,
        minSize,
        maxSize,
        newSize: size,
      };
      if (isBefore) beforeElements.unshift(data);
      else afterElements.push(data);
    });
    logElementsSizes();
  }

  function decreaseSizeRecursive(
    items: IElement[],
    deltaToDistribute: number,
  ): void {
    const item = items.shift();
    if (!item) {
      currentDragDelta -= deltaToDistribute;
      return;
    }
    const canDecreaseBy = item.initialSize - item.minSize;
    const actualDecrease = Math.min(deltaToDistribute, canDecreaseBy);
    item.newSize = item.initialSize - actualDecrease;

    if (actualDecrease <= deltaToDistribute) {
      decreaseSizeRecursive(items, deltaToDistribute - actualDecrease);
    } else {
      currentDragDelta -= deltaToDistribute;
    }
  }

  function increaseSizeRecursive(
    items: IElement[],
    deltaToDistribute: number,
  ): void {
    const item = items.shift();
    if (!item) {
      currentDragDelta -= deltaToDistribute;
      return;
    }
    const canIncreaseBy = item.maxSize - item.initialSize;
    const actualIncrease = Math.min(deltaToDistribute, canIncreaseBy);
    item.newSize = item.initialSize + actualIncrease;

    if (actualIncrease <= deltaToDistribute) {
      increaseSizeRecursive(items, deltaToDistribute - actualIncrease);
    } else {
      currentDragDelta -= deltaToDistribute;
    }
  }

  function applyNewSizes(): void {
    const allAffectedElements = [...beforeElements, ...afterElements];
    allAffectedElements.forEach((item) => {
      item.element.style.flexGrow = `${item.newSize}`;
    });
  }

  function handleTouchDown(event: TouchEvent): void {
    if (!customElementRef) return;

    event.preventDefault();
    isDragging = true;
    startX = event.touches[0]?.clientX ?? 0;
    startY = event.touches[0]?.clientY ?? 0;
    storeElements();

    window.addEventListener("touchmove", handleMouseMove);
    window.addEventListener("touchend", handleMouseUp);
  }

  function handleMouseDown(event: MouseEvent): void {
    if (!customElementRef) return;

    event.preventDefault();
    isDragging = true;
    startX = event.clientX;
    startY = event.clientY;
    storeElements();

    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }

function getMouseDelta(event: MouseEvent | TouchEvent): number {
  let clientX: number, clientY: number;

  if (event instanceof TouchEvent) {
    // Берём первый палец (обычно этого достаточно)
    clientX = event.touches[0]?.clientX ?? 0;
    clientY = event.touches[0]?.clientY ?? 0;
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }

  const mouseDelta = isRowDirection
    ? clientY - startY
    : clientX - startX;

  return mouseDelta;
}

  function handleMouseMove(event: MouseEvent | TouchEvent): void {
    if (!isDragging) return;

    let mouseDelta = getMouseDelta(event);

    currentDragDelta = Math.abs(mouseDelta);

    beforeElements.forEach((el) => (el.newSize = el.initialSize));
    afterElements.forEach((el) => (el.newSize = el.initialSize));

    if (mouseDelta < 0) {
      decreaseSizeRecursive([...beforeElements], currentDragDelta);
      increaseSizeRecursive([...afterElements], currentDragDelta);
      decreaseSizeRecursive([...beforeElements], currentDragDelta); // Повторный вызов из оригинала
    } else if (mouseDelta > 0) {
      increaseSizeRecursive([...beforeElements], currentDragDelta);
      decreaseSizeRecursive([...afterElements], currentDragDelta);
      increaseSizeRecursive([...beforeElements], currentDragDelta); // Повторный вызов из оригинала
    }
    applyNewSizes();
  }

  function handleMouseUp(): void {
    if (!isDragging) return;
    isDragging = false;
    window.removeEventListener("mousemove", handleMouseMove);
    window.removeEventListener("mouseup", handleMouseUp);
    window.removeEventListener("touchmove", handleMouseMove);
    window.removeEventListener("touchend", handleMouseUp);
    logElementsSizes();
  }
</script>

<div
  bind:this={internalDivRef}
  class="resizer {className}"
  class:cols={direction === "column"}
  class:rows={direction === "row"}
  class:dragging={isDragging}
  style:width={direction === "column" ? "2px" : "100%"}
  style:min-width={direction === "column" ? "2px" : undefined}
  style:max-width={direction === "column" ? "2px" : undefined}
  style:height={direction === "row" ? "2px" : "100%"}
  style:min-height={direction === "row" ? "2px" : undefined}
  style:max-height={direction === "row" ? "2px" : undefined}
  onmousedown={handleMouseDown}
  tabindex="0"
  role="separator"
>
  <div class="overlay1"></div>
  <div class="overlay2"></div>
</div>

<style>
  :host, .resizer {
    box-sizing: border-box;
    border: none;
    padding: 0;
    margin: 0;
    /* overflow: hidden; */
  }

  :host {
    /* flex: 0 0 4px; */
    padding: 0.5px;
  }

  .resizer {
    /* margin: 1px; */
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative; /* Оверлеи будут absolutely positioned относительно этого div */
    user-select: none;
    touch-action: none;
  }

  .resizer.cols {
    cursor: col-resize;
  }

  .resizer.rows {
    cursor: row-resize;
  }

  .resizer.cols .overlay1 {
    background: url("data:image/gif;base64,R0lGODlhAwAdAIABAJWr7f///yH5BAEAAAEALAAAAAADAB0AAAIQRBynaaje0pORrWnhrbi3AgA7")
      no-repeat center center;
  }
  .resizer.rows .overlay1 {
    background: url("data:image/gif;base64,R0lGODlhHQADAIABAJWr7f///yH5BAEAAAEALAAAAAAdAAMAAAINRIynyesBo5y0tuswKgA7")
      no-repeat center center;
  }

  .resizer:hover .overlay1 {
    background-color: #191919;
  }
  .resizer.dragging .overlay1,
  .resizer:active .overlay1 {
    background-color: #555;
  }

  .resizer.cols .overlay2 {
    transform: scaleX(4);
  }
  .resizer.rows .overlay2 {
    transform: scaleY(4);
  }

  .resizer.cols:hover .overlay2,
  .resizer.cols.dragging .overlay2,
  .resizer.cols:active .overlay2 {
    transform: scaleX(4);
  }
  .resizer.rows:hover .overlay2,
  .resizer.rows.dragging .overlay2,
  .resizer.rows:active .overlay2 {
    transform: scaleY(4);
  }

  .overlay1,
  .overlay2 {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  .overlay1 {
    background-color: #222;
  }
  .overlay2 {
    background: transparent;
  }
</style>
```

```
<svelte:options customElement={{ tag: "ohae-separator" }} />

<script lang="ts">
  import { onMount } from "svelte";
  import {
    determineResizerDirection,
    type TFlexDirection,
  } from "../../lib/layoutUtils";
  import { useShadowTheme } from "../../lib/useShadowTheme";

  let {
    size = 1,
    direction = "column" as TFlexDirection,
    className = undefined,
    resizeDeny = true,
  }: {
    size?: number | null;
    direction: TFlexDirection;
    className?: string;
    resizeDeny: boolean;
  } = $props();

  let internalDivRef: HTMLDivElement; // внутренний <div class="resizer">
  let customElementRef: HTMLElement; // кастомный элемент <ohae-resizer>

  useShadowTheme(() => internalDivRef?.getRootNode() as ShadowRoot | null);

  onMount(() => {
    if (internalDivRef) {
      const rootNode = internalDivRef.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        customElementRef = rootNode.host as HTMLElement;
      } else {
        customElementRef = internalDivRef;
      }
    }
    direction = determineResizerDirection(customElementRef) ?? direction;
  });

</script>

<div
  bind:this={internalDivRef}
  class="separator {className}"
  class:cols={direction === "column"}
  class:rows={direction === "row"}
  style:width={direction === "column" ? size+"px" : "100%"}
  style:min-width={direction === "column" ? size+"px" : undefined}
  style:max-width={direction === "column" ? size+"px" : undefined}
  style:height={direction === "row" ? size+"px" : "100%"}
  style:min-height={direction === "row" ? size+"px" : undefined}
  style:max-height={direction === "row" ? size+"px" : undefined}
  role="separator"
>
</div>

<style>
  :host, .separator {
    box-sizing: border-box;
    border: none;
    padding: 0;
    margin: 0;
    /* overflow: hidden; */
  }

  :host {
    /* flex: 0 0 4px; */
    padding: 0px;
  }

  .separator {
    /* margin: 1px; */
    display: flex;
    position: relative;
    user-select: none;
    background-color: #000;
  }
</style>
```

```
* {
    box-sizing: border-box;
}

:root {
    --background: #222;
    --color: #ccc;
    --margin: 0px;
    --paddind: 5px;
}

:root {
    font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
    line-height: 1.5;
    font-weight: 400;
    font-size: 12px;

    color-scheme: light dark;

    font-synthesis: none;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;

}



/* ===== Scrollbar CSS ===== */
/* Firefox */
* {
    scrollbar-width: thin;
    scrollbar-color: rgb(65, 94, 156) rgba(0, 0, 0, 0.2);
}
/* Chrome, Edge, and Safari */
*::-webkit-scrollbar {
    width: 16px;
}
*::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
}
*::-webkit-scrollbar-thumb {
    background-color: rgb(65, 94, 156);
    border-radius: 10px;
    border: 1px none rgba(0, 0, 0, 0.2);
}



.body.host {
    background-color: #222;
    color: #ccc;
}


.top.host {
    background-color: #383030;
    color: #dcc;
}
.top.slot {
    margin: 0 0px 0px 0;
    padding: 5px;
}

.bottom.host {
    background-color: #303830;
    color: #cdc;
}

.bottom.slot {
    margin: 0px 0px 0 0;
    padding: 5px;
}


.right.host {
    background-color: #303038;
    color: #ccd;
}

.right.slot {
    margin: 0 0 0 0px;
    padding: 5px;
}
```

оба варианта инициализируются примерно одинаково:

```
export type UiNodeConfig = IUiNodeConfig | string | number;

export interface IUiNodeConfig {
  view: string; // Имя тега (например, 'layout', 'resizer', 'div')
  body?: UiNodeConfig[] | UiNodeConfig; // Дочерние элементы или текстовое содержимое
  id?: string; // Опциональный ID для элемента
  // Плюс любые другие атрибуты/свойства, которые могут быть у элемента
  [key: string]: any;
}

export async function createUI(config: UiNodeConfig, parentElement: HTMLElement): Promise<HTMLElement|Text|null> {
  if (!config) {
    console.error("Invalid config:", config);
    return null;
  }
  return new Promise((resolve, reject) => {
    requestAnimationFrame(async () => {
      const slotContainer = parentElement.shadowRoot?.querySelector('.slot') as HTMLElement ?? parentElement.querySelector('.slot') as HTMLElement ?? parentElement;
      const element = createUiElement(config, slotContainer)
      if(element) {
        resolve(element)
      } else {
        reject(null);
        throw new Error(`Can'not create element for ${config}`);
      }
    });
  })
}

function createUiElement(config: UiNodeConfig, parentElement: HTMLElement): HTMLElement | Text | null {
  if (typeof config === 'object') {
    return renterElementFromJson(config, parentElement);
  } else {
    return renterElementFromText(config, parentElement);
  }
}

function renterElementFromJson(config: IUiNodeConfig, parentElement: HTMLElement): HTMLElement | null {
  if (!config.view) {
    console.error("Invalid config or missing view:", config);
    return null;
  }

  const tagName = config.view === 'layout' ? 'ohae-layout'
    : config.view === 'resizer' ? 'ohae-resizer'
    : config.view; // Для 'div', 'span' и т.д.


  const element = document.createElement(tagName);
  if(!element) {
    console.error("Invalid config or missing view:", config);
    return null;
  }


  setPropsAndAttributes(element, config);
  parentElement.appendChild(element);


  if (config.body) {
    // const slotContainer = element.shadowRoot?.querySelector('.slot') as HTMLElement ?? element.querySelector('.slot') as HTMLElement ?? element;
    if (Array.isArray(config.body)) {
      (config.body as UiNodeConfig[]).forEach((configChild: UiNodeConfig) => {
        createUI(configChild, element);
      });
    } else {
      createUI(config.body, element);
    }
  }

  return element;
}


function renterElementFromText(text: string | number, parentElement: HTMLElement): Text | null {
  if (text.toString().length === 0) {
    console.error("Invalid ctreate Text element for empty string");
    return null;
  }
  const element = document.createTextNode(text.toString());
  parentElement.appendChild(element);
  return element;
}


function setPropsAndAttributes(element: HTMLElement, config: IUiNodeConfig) {
  for (const key in config) {
    if (!config.hasOwnProperty(key) || key === 'view' || key === 'body') continue;
    const value = config[key];

    if (key === 'className') {
      if(typeof value === 'string') value.split(' ').forEach(cls => element.classList.add(cls));
    }


    if (key === 'style') {
      if (typeof value === 'string') element.setAttribute('style', value);
    } else if (key in element) {
      (element as any)[key] = value;
    } else if (typeof value === 'object'){
        (element as any)[key] = value;
    } else if (typeof value === 'boolean'){
        if (value) element.setAttribute(camelToKebab(key), '');
    }else{
        element.setAttribute(camelToKebab(key), String(value));
    }
  }
}

// Функция для преобразования camelCase в kebab-case для атрибутов
function camelToKebab(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
}
```

```
import type { IUiNodeConfig } from "../lib/jsonRenderer";

export const mainViewConfig: IUiNodeConfig = {
    view: 'layout',
    width: '100%',
    height: '100vh',
    flex: 1,
    direction: 'row',
    overflow: 'hidden',
    className: 'body',
    body: [
      {
        view: 'layout',
        direction: 'column',
        overflow: 'auto',
        body: [
          {
            view: 'layout',
            direction: 'column',
            overflow: 'auto',
            className: 'bottom',
            minHeight: 25,
            maxHeight: 75,
            body: [
              { view: 'div', body: 'minHeight: 25' },
              { view: 'div', body: 'maxHeight: 75' }
            ]
          },
          { view: 'separator' },
          {
            view: 'layout',
            direction: 'column',
            overflow: 'auto',
            // minHeight: 50,
            className: 'top',
            flex: 2,
            body: [
              { view: 'div', body: 'minHeight: 0' },
              { view: 'div', body: 'maxHeight: undefined' },
              { view: 'div', body: "111111111111111111111111" },
              { view: 'div', body: "222222222222222" },
              { view: 'div', body: "33333333333333" },
              { view: 'div', body: "444444444444" },
              { view: 'div', body: "555555555555" },
              { view: 'div', body: "66666666666" },
            ]
          },
          { view: 'resizer' },
          {
            view: 'layout',
            direction: 'column',
            overflow: 'auto',
            className: 'bottom',
            minHeight: 50, // Число будет преобразовано в 50px в layout
            body: [
              { view: 'div', body: 'minHeight: 50' },
              { view: 'div', body: 'maxHeight: undefined' }
            ]
          },
          { view: 'resizer' },
          {
            view: 'layout',
            id: 'tartet',
            direction: 'column',
            overflow: 'auto',
            className: 'top',
            flex: 1,
            minHeight: 100,
            maxHeight: 150,
            body: [
              { view: 'div', body: 'minHeight: 100' },
              { view: 'div', body: 'maxHeight: 150' }
            ]
          }
        ]
      },
      { view: 'resizer' },
      {
        view: 'layout',
        direction: 'row',
        overflow: 'auto',
        className: 'right',
        maxWidth: 50,
        minWidth: 50,
        body: [
          { view: 'div', body: 'minHeight: 0' },
          { view: 'div', body: 'maxHeight: undefined' }
        ]
      },
      { view: 'separator' },
      {
        view: 'layout',
        direction: 'row',
        overflow: 'auto',
        className: 'right',
        body: [
          { view: 'div', body: 'minHeight: 0' },
          { view: 'div', body: 'maxHeight: undefined' }
        ]
      },
    ]
  };
```

```
import './components/lauout/OhaeLayoutView.svelte';
import './components/lauout/OhaeResizerView.svelte';
import './components/lauout/OhaeSeparatorView.svelte';
import { mainViewConfig } from './ui-configs/mainViewConfig.js';
import { createUI } from './lib/jsonRenderer';

const appRootElement = document.getElementById('app');

(async ()=>{
  if (appRootElement) {
    await createUI(mainViewConfig, appRootElement);
  } else {
    console.error("Root element #app not found!");
  }


  themeStore.set('/themes/theme-default-dark.css');
})();

```

я хочу по аналогии переделать следующй webcomponent в компонент svelte версии 5.28

```
import { OhaeUI } from "../../OhaeUI";
import { OhaeBaseView } from "../base_view/OhaeBaseView";
import { IOhaeViewOptions } from "../../OhaeViewOptions";
import { Color } from "../../utils/Color";

export class OhaeIconOfTypeView extends OhaeBaseView {
    public static readonly ATTRIBUTES: string[] = [
        'value',
        'color',
    ];

    protected static readonly STYLES: string = `
        <style>
            :host {
                display: inline-flex;
                width: 16px;
                height: 16px;
                margin: 0;
                padding: 0;
                cursor: pointer;
                background: transparent !important;
                align-items: center;
                justify-content: center;
            }
            .icon {
                font-size: 100%;
                transition: opacity 0.2s;
            }
            .icon:hover {
                opacity: 0.8;
            }
        </style>
    ` + this.FONT_AVESOME;

    // protected static readonly HTML: string = ``;
    protected static readonly HTML: string = `
        <slot><span id='icon' class='icon fa fa-question-circle'></span></slot>
    `;

    private iconElement?: HTMLElement;

    constructor() {
        super();
    }

    static get observedAttributes() {
        return [...super.observedAttributes, ...this.ATTRIBUTES];
    }

    // protected async connectedCallback() {
	// 	await super.connectedCallback();
	// 	// this.markAsReady();
    // }

    protected override async createCallback() {
        await super.createCallback();
        // await this.waitForShadowRoot();
        this.applyAttributes(OhaeIconOfTypeView.ATTRIBUTES);
        this.iconElement = this.shadowRoot!.querySelector('span') as HTMLElement;
        this.updateIcon();
    }

    protected async render() {
		const staticThis = (this.constructor as typeof OhaeBaseView);
		this.shadowRoot!.innerHTML = staticThis.STYLES + staticThis.HTML;
	}

    private async getIcon(): Promise<IconOfTypeData | null> {
        if(!this.value) return null;
        const data = this.initData.types?.[this.value];
        if(!data) return null;

        return {
            ...data,
            color: new Color(data.color).hex
        };
    }

    private async updateIcon() {
        if (!this.iconElement) return;
        const data = await this.getIcon();
        this.iconElement.className = 'icon' +  (data ? ' fa ' + data.icon : '');
        this.iconElement.style.color = (data ? this.color?.rgba ?? data.color ?? "#ddd" : "#0000");
        // this.className = 'icon' +  (data ? ' fa ' + data.icon : '');
        // this.style.color = (data ? this.color?.rgba ?? data.color ?? "#ddd" : "#0000");
    }

    get color(): Color | null {
        const color = this.getAttribute('color');
        if (!color) return null;
        return new Color(color);
    }
    set color(value: string | Color | null) {
        if (!value) return;
        const color = typeof value === 'string' ? new Color(value) : value;
        this.setAttribute('color', color.hex);
        this.updateIcon();
    }

	get value(): string | null {
        return this.getAttribute('value');
    }
	set value(value: string | null) {
        if(value){
            this.setAttribute('value', value.toString());
        }else{
            this.removeAttribute('value')
        }
        this.updateIcon();
    }

}


OhaeUI.registerViewType('icon-of-type', OhaeIconOfTypeView);

type IconOfTypeData = Record<string, string>;
// Обновляем типы для OhaeViewOptions
declare module "../../OhaeViewOptions" {
    interface IOhaeViewOptions {
        value?: string | number | boolean | undefined;
        color?: string;
        types?: Record<string, IconOfTypeData>;
    }
}
```

